---
title: Testing Webhooks
description: "Test webhooks in development and production environments"
---

Testing webhooks requires a different approach than testing typical API integrations. Since webhooks are push-based, your local development server isn't directly accessible from Lettr's servers. This guide covers strategies for testing webhooks at every stage of development.

## Local Development

During local development, you need a way to receive webhooks on your machine. There are several approaches.

### Using ngrok

[ngrok](https://ngrok.com) creates a secure tunnel from a public URL to your local server, allowing Lettr to send webhooks directly to your development machine.

1. **Install ngrok**:

```bash
# macOS
brew install ngrok

# Or download from https://ngrok.com/download
```

2. **Start your local server**:

```bash
npm run dev  # Your app running on port 3000
```

3. **Create a tunnel**:

```bash
ngrok http 3000
```

4. **Copy the HTTPS URL**:

```
Forwarding  https://abc123.ngrok.io -> http://localhost:3000
```

5. **Configure webhook in Lettr**:

```javascript
const webhook = await lettr.webhooks.create({
  url: 'https://abc123.ngrok.io/webhooks/lettr',
  events: ['email.delivered', 'email.bounced', 'email.received']
});
```

<Tip>
  Use ngrok's paid plan to get a stable subdomain. Free URLs change each time you restart ngrok.
</Tip>

### Using Cloudflare Tunnel

[Cloudflare Tunnel](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/) provides a similar capability:

```bash
# Install cloudflared
brew install cloudflared

# Create tunnel
cloudflared tunnel --url http://localhost:3000
```

### Using localtunnel

[localtunnel](https://github.com/localtunnel/localtunnel) is a free, open-source alternative:

```bash
npx localtunnel --port 3000
```

## Dashboard Test Events

The Lettr dashboard provides a built-in way to send test webhook events without triggering real email activity.

### Sending Test Events

1. Navigate to **Settings** → **Webhooks**
2. Select the webhook you want to test
3. Click **Send Test Event**
4. Choose the event type (e.g., `email.delivered`, `email.received`)
5. Click **Send**

The dashboard will show the delivery result, including response code and timing.

### Test Event Payloads

Test events have the same structure as real events but with sample data:

```json
{
  "id": "evt_test_123456",
  "type": "email.delivered",
  "createdAt": "2024-01-15T10:30:00Z",
  "data": {
    "emailId": "email_test_789",
    "to": "test@example.com",
    "deliveredAt": "2024-01-15T10:30:05Z",
    "metadata": {}
  }
}
```

<Note>
  Test events have IDs prefixed with `evt_test_`. You can use this to identify test events in your logs if needed.
</Note>

## API-Based Testing

Trigger test events programmatically via the API:

```javascript
// Send a test event to a specific webhook
await lettr.webhooks.test('wh_123', {
  eventType: 'email.delivered'
});

// Send test event with custom data
await lettr.webhooks.test('wh_123', {
  eventType: 'email.received',
  data: {
    from: 'test-sender@example.com',
    subject: 'Test inbound email',
    text: 'This is a test message'
  }
});
```

## Unit Testing Your Handler

Test your webhook handler logic without making real HTTP requests.

### Basic Unit Test

```javascript
import { describe, it, expect, vi } from 'vitest';
import { handleWebhook } from './webhookHandler';

describe('Webhook Handler', () => {
  it('handles email.delivered event', async () => {
    const mockDb = {
      emails: {
        update: vi.fn()
      }
    };

    const event = {
      id: 'evt_123',
      type: 'email.delivered',
      createdAt: '2024-01-15T10:30:00Z',
      data: {
        emailId: 'email_456',
        to: 'recipient@example.com',
        deliveredAt: '2024-01-15T10:30:05Z'
      }
    };

    await handleWebhook(event, { db: mockDb });

    expect(mockDb.emails.update).toHaveBeenCalledWith('email_456', {
      status: 'delivered',
      delivered_at: expect.any(Date)
    });
  });

  it('handles email.bounced event', async () => {
    const mockDb = {
      emails: { update: vi.fn() },
      suppressions: { add: vi.fn() }
    };

    const event = {
      id: 'evt_789',
      type: 'email.bounced',
      data: {
        emailId: 'email_456',
        to: 'invalid@example.com',
        bounceType: 'hard',
        message: '550 User unknown'
      }
    };

    await handleWebhook(event, { db: mockDb });

    expect(mockDb.suppressions.add).toHaveBeenCalledWith(
      'invalid@example.com',
      'hard_bounce'
    );
  });

  it('handles email.received event', async () => {
    const mockTicketService = {
      create: vi.fn().mockResolvedValue({ id: 'ticket_123' })
    };

    const event = {
      id: 'evt_abc',
      type: 'email.received',
      data: {
        id: 'inbound_123',
        from: 'customer@example.com',
        subject: 'Help needed',
        text: 'I have a question...',
        spamScore: 0.5
      }
    };

    await handleWebhook(event, { ticketService: mockTicketService });

    expect(mockTicketService.create).toHaveBeenCalledWith({
      sender: 'customer@example.com',
      subject: 'Help needed',
      body: 'I have a question...'
    });
  });

  it('skips duplicate events', async () => {
    const mockDb = {
      processedEvents: {
        exists: vi.fn().mockResolvedValue(true)
      },
      emails: { update: vi.fn() }
    };

    const event = {
      id: 'evt_duplicate',
      type: 'email.delivered',
      data: { emailId: 'email_123' }
    };

    await handleWebhook(event, { db: mockDb });

    expect(mockDb.emails.update).not.toHaveBeenCalled();
  });
});
```

### Testing Signature Verification

```javascript
import crypto from 'crypto';
import { verifyWebhookSignature } from './webhookHandler';

describe('Signature Verification', () => {
  const secret = 'whsec_test_secret';

  function generateSignature(payload, timestamp = Math.floor(Date.now() / 1000)) {
    const signedPayload = `${timestamp}.${payload}`;
    const signature = crypto
      .createHmac('sha256', secret)
      .update(signedPayload)
      .digest('hex');
    return `t=${timestamp},v1=${signature}`;
  }

  it('accepts valid signature', () => {
    const payload = JSON.stringify({ id: 'evt_123', type: 'email.delivered' });
    const signature = generateSignature(payload);

    const result = verifyWebhookSignature(payload, signature, secret);

    expect(result).toEqual({ id: 'evt_123', type: 'email.delivered' });
  });

  it('rejects invalid signature', () => {
    const payload = JSON.stringify({ id: 'evt_123' });
    const signature = 't=1234567890,v1=invalid_signature';

    expect(() => {
      verifyWebhookSignature(payload, signature, secret);
    }).toThrow('Invalid signature');
  });

  it('rejects old timestamp', () => {
    const payload = JSON.stringify({ id: 'evt_123' });
    const oldTimestamp = Math.floor(Date.now() / 1000) - 400; // 6+ minutes ago
    const signature = generateSignature(payload, oldTimestamp);

    expect(() => {
      verifyWebhookSignature(payload, signature, secret);
    }).toThrow('Timestamp too old');
  });

  it('rejects tampered payload', () => {
    const originalPayload = JSON.stringify({ id: 'evt_123', amount: 100 });
    const signature = generateSignature(originalPayload);

    const tamperedPayload = JSON.stringify({ id: 'evt_123', amount: 1000 });

    expect(() => {
      verifyWebhookSignature(tamperedPayload, signature, secret);
    }).toThrow('Invalid signature');
  });
});
```

## Integration Testing

Test the full webhook flow including HTTP handling.

### Using Supertest

```javascript
import request from 'supertest';
import crypto from 'crypto';
import { app } from './app';

describe('Webhook Endpoint', () => {
  const secret = process.env.LETTR_WEBHOOK_SECRET;

  function createSignedRequest(payload) {
    const timestamp = Math.floor(Date.now() / 1000);
    const body = JSON.stringify(payload);
    const signedPayload = `${timestamp}.${body}`;
    const signature = crypto
      .createHmac('sha256', secret)
      .update(signedPayload)
      .digest('hex');

    return {
      body,
      signature: `t=${timestamp},v1=${signature}`
    };
  }

  it('returns 200 for valid webhook', async () => {
    const { body, signature } = createSignedRequest({
      id: 'evt_123',
      type: 'email.delivered',
      data: { emailId: 'email_456' }
    });

    const response = await request(app)
      .post('/webhooks/lettr')
      .set('Content-Type', 'application/json')
      .set('Lettr-Signature', signature)
      .send(body);

    expect(response.status).toBe(200);
  });

  it('returns 400 for invalid signature', async () => {
    const response = await request(app)
      .post('/webhooks/lettr')
      .set('Content-Type', 'application/json')
      .set('Lettr-Signature', 't=123,v1=invalid')
      .send(JSON.stringify({ id: 'evt_123' }));

    expect(response.status).toBe(400);
  });

  it('returns 400 for missing signature', async () => {
    const response = await request(app)
      .post('/webhooks/lettr')
      .set('Content-Type', 'application/json')
      .send(JSON.stringify({ id: 'evt_123' }));

    expect(response.status).toBe(400);
  });
});
```

## End-to-End Testing

Test the complete flow from sending an email to receiving webhooks.

### Trigger Real Events

Send actual emails to trigger genuine webhook events:

```javascript
// test/e2e/webhooks.test.js
import { lettr } from './client';
import { waitForWebhook } from './helpers';

describe('Webhook E2E', () => {
  it('receives delivery webhook after sending email', async () => {
    // Send an email
    const { data: email } = await lettr.emails.send({
      from: 'test@yourdomain.com',
      to: ['verified-test@example.com'], // Use a verified test address
      subject: 'E2E Test',
      text: 'Testing webhook delivery'
    });

    // Wait for webhook (with timeout)
    const webhook = await waitForWebhook({
      type: 'email.delivered',
      emailId: email.id,
      timeout: 60000 // 60 seconds
    });

    expect(webhook.type).toBe('email.delivered');
    expect(webhook.data.emailId).toBe(email.id);
  }, 120000); // Jest timeout
});
```

### Webhook Collector Helper

Create a helper to capture webhooks during tests:

```javascript
// test/helpers/webhookCollector.js
import express from 'express';

export function createWebhookCollector(port = 4000) {
  const app = express();
  const events = [];
  const waiters = [];

  app.use(express.json());

  app.post('/webhooks', (req, res) => {
    events.push(req.body);

    // Check if any waiters match this event
    waiters.forEach((waiter, index) => {
      if (waiter.matches(req.body)) {
        waiter.resolve(req.body);
        waiters.splice(index, 1);
      }
    });

    res.sendStatus(200);
  });

  const server = app.listen(port);

  return {
    url: `http://localhost:${port}/webhooks`,
    events,

    waitFor(predicate, timeout = 30000) {
      return new Promise((resolve, reject) => {
        // Check existing events
        const existing = events.find(predicate);
        if (existing) {
          return resolve(existing);
        }

        // Wait for matching event
        const timer = setTimeout(() => {
          reject(new Error('Webhook wait timeout'));
        }, timeout);

        waiters.push({
          matches: predicate,
          resolve: (event) => {
            clearTimeout(timer);
            resolve(event);
          }
        });
      });
    },

    clear() {
      events.length = 0;
    },

    close() {
      server.close();
    }
  };
}

// Usage in tests
const collector = createWebhookCollector();

// Configure webhook to point to collector
await lettr.webhooks.create({
  url: collector.url,
  events: ['email.delivered']
});

// Send email and wait for webhook
await lettr.emails.send({ /* ... */ });

const event = await collector.waitFor(
  (e) => e.type === 'email.delivered'
);

collector.close();
```

## Staging Environment Testing

Before deploying to production, test webhooks in a staging environment.

### Checklist

1. **Configure staging webhook endpoint**
   ```javascript
   await lettr.webhooks.create({
     url: 'https://staging.example.com/webhooks/lettr',
     events: ['*']
   });
   ```

2. **Verify SSL certificate** - Ensure your staging environment has a valid SSL certificate

3. **Test all event types** - Send test events for each type you handle

4. **Test retry handling** - Temporarily return errors to verify retry behavior

5. **Test signature verification** - Confirm your staging environment uses the correct secret

6. **Load testing** - Send multiple webhooks to test concurrent handling

### Simulating Failures

Test how your system handles webhook failures:

```javascript
// Temporarily fail webhooks to test retry behavior
let failCount = 0;

app.post('/webhooks/lettr', (req, res) => {
  if (failCount < 3) {
    failCount++;
    console.log(`Simulating failure ${failCount}`);
    return res.sendStatus(500);
  }

  // Process normally after 3 failures
  processWebhook(req.body);
  res.sendStatus(200);
});
```

## Debugging Webhooks

### Logging Incoming Webhooks

Add comprehensive logging during development:

```javascript
app.post('/webhooks/lettr', express.raw({ type: 'application/json' }), (req, res) => {
  console.log('=== Webhook Received ===');
  console.log('Headers:', JSON.stringify(req.headers, null, 2));
  console.log('Body:', req.body.toString());
  console.log('Signature:', req.headers['lettr-signature']);
  console.log('========================');

  // ... rest of handler
});
```

### Request Inspection Tools

Use tools like [Webhook.site](https://webhook.site) or [RequestBin](https://requestbin.com) to inspect webhook payloads:

1. Get a temporary URL from Webhook.site
2. Configure a test webhook to that URL
3. Send test events and inspect the raw requests
4. Copy the payload structure for your tests

### Dashboard Delivery Logs

The Lettr dashboard shows detailed delivery logs:

1. Go to **Settings** → **Webhooks**
2. Select your webhook
3. View **Delivery History**
4. Click on any delivery to see:
   - Request payload
   - Response code
   - Response body (if any)
   - Timing information
   - Retry attempts

## Common Testing Pitfalls

<AccordionGroup>
  <Accordion title="JSON parsing before signature verification">
    Always verify the signature using the raw body. If you parse JSON first, the re-stringified version may differ from the original.

    ```javascript
    // Wrong
    app.post('/webhooks', express.json(), (req, res) => {
      const body = JSON.stringify(req.body); // May differ from original
      verifySignature(body, signature, secret);
    });

    // Right
    app.post('/webhooks', express.raw({ type: 'application/json' }), (req, res) => {
      verifySignature(req.body.toString(), signature, secret);
    });
    ```
  </Accordion>

  <Accordion title="Hardcoded test secrets in production">
    Never commit webhook secrets to source control. Use environment variables.

    ```javascript
    // Wrong
    const secret = 'whsec_abc123';

    // Right
    const secret = process.env.LETTR_WEBHOOK_SECRET;
    ```
  </Accordion>

  <Accordion title="Not testing idempotency">
    Always test that your handler correctly handles duplicate events.

    ```javascript
    it('handles duplicate events idempotently', async () => {
      const event = createTestEvent('email.delivered');

      // Process twice
      await handleWebhook(event);
      await handleWebhook(event);

      // Should only have one record
      const records = await db.deliveries.count({ eventId: event.id });
      expect(records).toBe(1);
    });
    ```
  </Accordion>

  <Accordion title="Not testing error scenarios">
    Test what happens when downstream services fail.

    ```javascript
    it('handles database errors gracefully', async () => {
      mockDb.update.mockRejectedValue(new Error('Connection lost'));

      const event = createTestEvent('email.delivered');

      // Should not throw, but should store for retry
      await handleWebhook(event);

      expect(mockFailedEventStore.add).toHaveBeenCalled();
    });
    ```
  </Accordion>
</AccordionGroup>

## Related Topics

<CardGroup cols={2}>
  <Card title="Handling Webhooks" icon="code" href="/learn/webhooks/handling">
    Best practices for processing webhooks reliably
  </Card>
  <Card title="Authorization" icon="lock" href="/learn/webhooks/authorization">
    Secure your endpoints with signature verification
  </Card>
  <Card title="Retries" icon="rotate" href="/learn/webhooks/retries">
    Understand retry behavior and failure handling
  </Card>
  <Card title="Event Types" icon="list" href="/learn/webhooks/event-types">
    Complete reference of all webhook events
  </Card>
</CardGroup>
