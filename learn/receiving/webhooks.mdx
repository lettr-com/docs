---
title: Webhooks
description: "Receive real-time notifications when emails arrive"
---

# Inbound Email Webhooks

When an email is received on your inbound domain, Lettr sends a webhook to your configured endpoint with the parsed email data.

## How It Works

<Steps>
  <Step title="Email Arrives">
    Someone sends an email to an address on your inbound domain (e.g., `support@mail.example.com`).
  </Step>
  <Step title="Lettr Processes">
    Lettr receives the email, parses the content, and extracts attachments.
  </Step>
  <Step title="Webhook Sent">
    A POST request is sent to your webhook endpoint with the structured email data.
  </Step>
  <Step title="You Process">
    Your application processes the email and returns a 200 response.
  </Step>
</Steps>

## Webhook Event Type

Inbound emails trigger the `email.received` event:

```json
{
  "id": "evt_abc123",
  "type": "email.received",
  "createdAt": "2024-01-15T10:30:15Z",
  "data": {
    "id": "inbound_123abc",
    "from": "sender@example.com",
    "fromName": "John Sender",
    "to": ["support@mail.example.com"],
    "cc": ["team@mail.example.com"],
    "bcc": [],
    "replyTo": "sender@example.com",
    "subject": "Help with my order",
    "text": "Hi, I need help with order #12345...",
    "html": "<p>Hi, I need help with order #12345...</p>",
    "attachments": [
      {
        "filename": "screenshot.png",
        "contentType": "image/png",
        "size": 24680,
        "url": "https://inbound.lettr.com/attachments/abc123"
      }
    ],
    "headers": {
      "message-id": "<abc123@example.com>",
      "date": "Mon, 15 Jan 2024 10:30:00 +0000",
      "in-reply-to": "<original123@example.com>",
      "references": "<original123@example.com>"
    },
    "receivedAt": "2024-01-15T10:30:15Z",
    "spamScore": 0.2,
    "domain": "mail.example.com"
  }
}
```

## Payload Reference

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique identifier for the inbound email |
| `from` | string | Sender's email address |
| `fromName` | string | Sender's display name (if provided) |
| `to` | string[] | Recipient email addresses |
| `cc` | string[] | CC recipients |
| `bcc` | string[] | BCC recipients (if visible) |
| `replyTo` | string | Reply-to address |
| `subject` | string | Email subject line |
| `text` | string | Plain text body |
| `html` | string | HTML body |
| `attachments` | array | List of attachments |
| `headers` | object | Raw email headers |
| `receivedAt` | string | ISO 8601 timestamp when received |
| `spamScore` | number | Spam score (0-10, lower is better) |
| `domain` | string | Inbound domain that received the email |

## Setting Up Your Webhook

### Subscribe to Inbound Events

Create a webhook that listens for `email.received` events:

```javascript
const webhook = await lettr.webhooks.create({
  url: 'https://example.com/webhooks/inbound',
  events: ['email.received']
});

// Store the webhook secret securely
console.log(webhook.secret);
```

### Handle Incoming Webhooks

```javascript
import express from 'express';
import { verifyWebhook } from 'lettr';

const app = express();

app.post('/webhooks/inbound', express.raw({ type: 'application/json' }), async (req, res) => {
  const signature = req.headers['lettr-signature'];

  try {
    // Verify the webhook signature
    const event = verifyWebhook(
      req.body,
      signature,
      process.env.LETTR_WEBHOOK_SECRET
    );

    if (event.type === 'email.received') {
      const {
        id,
        from,
        fromName,
        to,
        subject,
        text,
        html,
        attachments,
        headers
      } = event.data;

      // Process the inbound email
      await processInboundEmail({
        externalId: id,
        sender: from,
        senderName: fromName,
        recipients: to,
        subject,
        body: html || text,
        attachments,
        messageId: headers['message-id']
      });
    }

    res.sendStatus(200);
  } catch (err) {
    console.error('Webhook error:', err.message);
    res.sendStatus(400);
  }
});
```

## Handling Multiple Recipients

When an email is sent to multiple addresses on your domain, you'll receive one webhook per unique recipient address:

```javascript
app.post('/webhooks/inbound', async (req, res) => {
  const { to, subject, text } = req.body.data;

  // Process for each recipient
  for (const recipient of to) {
    await routeEmail(recipient, { subject, text });
  }

  res.sendStatus(200);
});
```

## Responding to Webhooks

Always respond with a 200 status code to acknowledge receipt:

```javascript
// Good - Always respond quickly
app.post('/webhooks/inbound', async (req, res) => {
  // Acknowledge immediately
  res.sendStatus(200);

  // Process asynchronously
  setImmediate(async () => {
    await processEmail(req.body);
  });
});
```

<Warning>
  If your endpoint doesn't return a 200 response within 30 seconds, Lettr will retry the webhook. Process emails asynchronously to avoid timeouts.
</Warning>

## Webhook Retry Behavior

Failed webhooks are retried with exponential backoff:

| Attempt | Delay |
|---------|-------|
| 1 | Immediate |
| 2 | 1 minute |
| 3 | 5 minutes |
| 4 | 30 minutes |
| 5 | 2 hours |
| 6 | 8 hours |

After 6 failed attempts, the webhook is marked as failed and stored for manual review.

## Testing Inbound Webhooks

### Using the Dashboard

1. Go to **Webhooks** in your dashboard
2. Find your webhook and click **Test**
3. Select `email.received` as the event type
4. Click **Send Test Event**

### Using a Tunnel for Local Development

Use a tool like ngrok to expose your local server:

```bash
ngrok http 3000
```

Then configure your webhook URL to use the ngrok URL during development.

## Idempotency

Implement idempotency to handle duplicate webhooks:

```javascript
const processedEvents = new Set();

app.post('/webhooks/inbound', async (req, res) => {
  const { id } = req.body.data;

  // Check if already processed
  if (processedEvents.has(id)) {
    return res.sendStatus(200);
  }

  // Mark as processed
  processedEvents.add(id);

  // Process the email
  await processEmail(req.body.data);

  res.sendStatus(200);
});
```

<Tip>
  For production, store processed event IDs in a database (Redis, PostgreSQL) instead of an in-memory Set.
</Tip>

## Security

Always verify webhook signatures before processing:

```javascript
import crypto from 'crypto';

function verifySignature(payload, signature, secret) {
  const elements = signature.split(',');
  const timestamp = elements.find(e => e.startsWith('t=')).slice(2);
  const expectedSig = elements.find(e => e.startsWith('v1=')).slice(3);

  // Reject old timestamps
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) {
    throw new Error('Timestamp too old');
  }

  // Compute expected signature
  const signedPayload = `${timestamp}.${payload}`;
  const computedSig = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');

  if (!crypto.timingSafeEqual(
    Buffer.from(expectedSig),
    Buffer.from(computedSig)
  )) {
    throw new Error('Invalid signature');
  }

  return JSON.parse(payload);
}
```

## Related Topics

<CardGroup cols={2}>
  <Card title="Webhook Authorization" icon="lock" href="/learn/webhooks/authorization">
    Secure your webhook endpoints
  </Card>
  <Card title="Webhook Retries" icon="rotate" href="/learn/webhooks/retries">
    Understand retry behavior
  </Card>
  <Card title="Routing" icon="route" href="/learn/receiving/routing">
    Route emails to different handlers
  </Card>
  <Card title="Attachments" icon="paperclip" href="/learn/receiving/attachments">
    Handle incoming attachments
  </Card>
</CardGroup>
