---
title: Receiving Introduction
description: "Receive and process incoming emails programmatically with Lettr"
---

# Receiving Emails

Lettr allows you to receive and process incoming emails programmatically. By configuring an inbound domain and setting up webhooks, your application can capture replies to transactional emails, process support requests, parse incoming data, and trigger automated workflows whenever an email arrives.

## What You Can Build

- **Support Ticket Systems** - Automatically create tickets from customer emails
- **Reply Tracking** - Capture replies to your transactional emails and thread conversations
- **Email-to-Action Workflows** - Trigger processes when specific emails arrive
- **Data Extraction** - Parse structured data from incoming emails (orders, receipts, notifications)
- **Email Forwarding** - Receive, process, and forward emails with transformations
- **Unsubscribe Processing** - Handle unsubscribe requests via email

## How It Works

<Steps>
  <Step title="Configure Inbound Domain">
    Add an inbound domain in your Lettr dashboard and configure MX records to route incoming emails to Lettr's mail servers.
  </Step>
  <Step title="Set Up Webhook">
    Create a webhook endpoint in your application to receive parsed email data when emails arrive.
  </Step>
  <Step title="Receive and Process">
    When someone sends an email to your inbound domain, Lettr parses it and sends the structured data to your webhook.
  </Step>
  <Step title="Build Your Logic">
    Route emails, extract data, trigger workflows, and respond programmatically.
  </Step>
</Steps>

## Quick Start

### 1. Add an Inbound Domain

Navigate to **Domains** â†’ **Inbound** in your dashboard or use the API:

```javascript
const response = await fetch('https://app.lettr.com/api/domains/inbound', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer le_xxxxxxxxxxxx',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    domain: 'mail.example.com'
  })
});
```

### 2. Configure DNS

Add the provided MX records to your domain:

| Type | Priority | Value |
|------|----------|-------|
| MX | 5 | `rx1.sparkpostmail.com` |
| MX | 10 | `rx2.sparkpostmail.com` |
| MX | 20 | `rx3.sparkpostmail.com` |

### 3. Handle Incoming Emails

Set up a webhook endpoint to receive parsed emails:

```javascript
import express from 'express';
import { verifyWebhook } from 'lettr';

const app = express();

app.post('/webhooks/inbound', express.raw({ type: 'application/json' }), async (req, res) => {
  // Verify the webhook signature
  const event = verifyWebhook(
    req.body,
    req.headers['lettr-signature'],
    process.env.LETTR_WEBHOOK_SECRET
  );

  if (event.type === 'email.received') {
    const { from, subject, text, html, attachments } = event.data;

    // Process the email
    await processIncomingEmail({
      sender: from,
      subject,
      body: text || html,
      attachments
    });
  }

  res.sendStatus(200);
});
```

## Webhook Payload

When an email is received, Lettr sends a webhook with fully parsed data:

```json
{
  "id": "evt_abc123",
  "type": "email.received",
  "createdAt": "2024-01-15T10:30:15Z",
  "data": {
    "id": "inbound_123abc",
    "from": "sender@example.com",
    "fromName": "John Sender",
    "to": ["support@mail.example.com"],
    "cc": ["team@example.com"],
    "replyTo": "sender@example.com",
    "subject": "Help with my order",
    "text": "Plain text content of the email...",
    "html": "<p>HTML content of the email...</p>",
    "attachments": [
      {
        "filename": "receipt.pdf",
        "contentType": "application/pdf",
        "size": 12345,
        "url": "https://inbound.lettr.com/attachments/abc123"
      }
    ],
    "headers": {
      "message-id": "<abc123@example.com>",
      "date": "Mon, 15 Jan 2024 10:30:00 +0000",
      "in-reply-to": "<original@example.com>"
    },
    "receivedAt": "2024-01-15T10:30:15Z",
    "spamScore": 0.5,
    "domain": "mail.example.com"
  }
}
```

## Key Capabilities

### Email Routing

Route incoming emails to different handlers based on recipient, content, or custom rules:

```javascript
app.post('/webhooks/inbound', async (req, res) => {
  const { to, from, subject, text } = req.body.data;
  const recipient = to[0].toLowerCase();

  if (recipient.startsWith('support@')) {
    await createSupportTicket({ from, subject, body: text });
  } else if (recipient.startsWith('sales@')) {
    await notifySalesTeam({ from, subject, body: text });
  } else if (recipient.match(/^reply\+/)) {
    const ticketId = recipient.match(/^reply\+([^@]+)@/)[1];
    await addReplyToTicket(ticketId, { from, body: text });
  }

  res.sendStatus(200);
});
```

### Spam Filtering

Every email includes a spam score, and you can configure automatic filtering:

```javascript
// Filter based on spam score
if (email.spamScore >= 6) {
  await quarantineAsSpam(email);
  return;
}

// Or configure domain-level filtering
await lettr.domains.update('mail.example.com', {
  spamFilter: 'aggressive' // 'off', 'moderate', 'aggressive'
});
```

### Attachment Handling

Attachments are automatically extracted and made available via secure URLs:

```javascript
for (const attachment of email.attachments) {
  const response = await fetch(attachment.url);
  const buffer = await response.arrayBuffer();
  await saveToStorage(attachment.filename, Buffer.from(buffer));
}
```

<Warning>
  Attachment URLs expire after 24 hours. Download and store attachments promptly if you need them longer.
</Warning>

### Reply Tracking

Track replies to your transactional emails by using variable reply-to addresses:

```javascript
// When sending an email
await lettr.emails.send({
  from: 'support@example.com',
  to: ['customer@example.com'],
  subject: 'Your support request',
  html: content,
  reply_to: `reply+ticket_${ticketId}@mail.example.com`
});

// When receiving the reply
const match = recipient.match(/^reply\+ticket_([^@]+)@/);
if (match) {
  const ticketId = match[1];
  await addReplyToTicket(ticketId, emailData);
}
```

## Using Subdomains

We recommend using a subdomain for inbound email to keep it separate from your primary email:

| Subdomain | Use Case |
|-----------|----------|
| `mail.example.com` | General inbound processing |
| `reply.example.com` | Reply tracking for transactional emails |
| `support.example.com` | Customer support emails |
| `inbound.example.com` | Automated workflow triggers |

This lets you keep your root domain's MX records pointing to your regular email provider while routing specific subdomains through Lettr.

## Learn More

<CardGroup cols={2}>
  <Card title="Setup Guide" icon="gear" href="/learn/receiving/setup">
    Step-by-step domain and webhook configuration
  </Card>
  <Card title="Webhooks" icon="webhook" href="/learn/webhooks/introduction">
    Webhook configuration and event handling
  </Card>
  <Card title="Routing" icon="route" href="/learn/receiving/routing">
    Route emails to different handlers
  </Card>
  <Card title="Attachments" icon="paperclip" href="/learn/receiving/attachments">
    Handle incoming file attachments
  </Card>
  <Card title="Spam Filtering" icon="shield" href="/learn/receiving/spam-filtering">
    Filter and manage spam
  </Card>
  <Card title="Reply Tracking" icon="reply" href="/learn/receiving/reply-tracking">
    Track and thread email replies
  </Card>
  <Card title="Email Parsing" icon="code" href="/learn/receiving/parsing">
    Understanding parsed email data
  </Card>
  <Card title="Security" icon="lock" href="/learn/receiving/security">
    Secure your inbound processing
  </Card>
  <Card title="Best Practices" icon="star" href="/learn/receiving/best-practices">
    Build reliable email processing
  </Card>
</CardGroup>

## Related Topics

<CardGroup cols={2}>
  <Card title="Inbound Domains" icon="globe" href="/learn/domains/inbound-domains">
    Domain configuration details
  </Card>
  <Card title="Webhooks Overview" icon="bell" href="/learn/webhooks/introduction">
    General webhook documentation
  </Card>
</CardGroup>
