---
title: Receiving Introduction
description: "Receive and process incoming emails programmatically with Lettr"
---

Lettr allows you to receive and process incoming emails programmatically. By configuring an inbound domain and setting up webhooks, your application can capture replies to transactional emails, process support requests, parse incoming data, and trigger automated workflows whenever an email arrives.

## What You Can Build

- **Support Ticket Systems** - Automatically create tickets from customer emails
- **Reply Tracking** - Capture replies to your transactional emails and thread conversations
- **Email-to-Action Workflows** - Trigger processes when specific emails arrive
- **Data Extraction** - Parse structured data from incoming emails (orders, receipts, notifications)
- **Email Forwarding** - Receive, process, and forward emails with transformations
- **Unsubscribe Processing** - Handle unsubscribe requests via email

## How It Works

Lettr's inbound email processing follows a four-step flow. You configure DNS to route emails to Lettr's mail servers, and Lettr parses each email into structured data and delivers it to your application via webhook.

<Steps>
  <Step title="Configure Inbound Domain">
    Add an inbound domain in your Lettr dashboard and configure MX records to route incoming emails to Lettr's mail servers.
  </Step>
  <Step title="Set Up Webhook">
    Create a webhook endpoint in your application to receive parsed email data when emails arrive.
  </Step>
  <Step title="Receive and Process">
    When someone sends an email to your inbound domain, Lettr parses it and sends the structured data to your webhook.
  </Step>
  <Step title="Build Your Logic">
    Route emails, extract data, trigger workflows, and respond programmatically.
  </Step>
</Steps>

```
Sender → MX Records → Lettr Mail Servers → Parse & Extract → Webhook → Your Application
```

Lettr handles the low-level SMTP reception, MIME parsing, attachment extraction, and spam scoring. Your application receives clean, structured JSON with the email's sender, recipients, subject, body (both plain text and HTML), headers, and attachment URLs.

## Quick Start

### 1. Add an Inbound Domain

Navigate to **Domains** → **Inbound** in your dashboard or use the API:

```javascript
const response = await fetch('https://app.lettr.com/api/domains/inbound', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer lttr_xxxxxxxxxxxx',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    domain: 'mail.example.com'
  })
});
```

### 2. Configure DNS

Add the provided MX records to your domain:

| Type | Priority | Value |
|------|----------|-------|
| MX | 5 | `rx1.sparkpostmail.com` |
| MX | 10 | `rx2.sparkpostmail.com` |
| MX | 20 | `rx3.sparkpostmail.com` |

Multiple MX records with different priorities ensure failover — if the primary server is unavailable, email is delivered to the next priority. See the [Setup Guide](/learn/receiving/setup) for DNS propagation details.

### 3. Handle Incoming Emails

Set up a webhook endpoint to receive parsed emails:

```javascript
import express from 'express';
import { verifyWebhook } from 'lettr';

const app = express();

app.post('/webhooks/inbound', express.raw({ type: 'application/json' }), async (req, res) => {
  // Verify the webhook signature
  const event = verifyWebhook(
    req.body,
    req.headers['lettr-signature'],
    process.env.LETTR_WEBHOOK_SECRET
  );

  if (event.type === 'email.received') {
    const { from, subject, text, html, attachments } = event.data;

    // Process the email
    await processIncomingEmail({
      sender: from,
      subject,
      body: text || html,
      attachments
    });
  }

  res.sendStatus(200);
});
```

<Warning>
  Always [verify the webhook signature](/learn/receiving/security) before processing incoming emails to ensure requests are genuinely from Lettr.
</Warning>

## Webhook Payload

When an email is received, Lettr sends a webhook with fully parsed data:

```json
{
  "id": "evt_abc123",
  "type": "email.received",
  "createdAt": "2024-01-15T10:30:15Z",
  "data": {
    "id": "inbound_123abc",
    "from": "sender@example.com",
    "fromName": "John Sender",
    "to": ["support@mail.example.com"],
    "cc": ["team@example.com"],
    "replyTo": "sender@example.com",
    "subject": "Help with my order",
    "text": "Plain text content of the email...",
    "html": "<p>HTML content of the email...</p>",
    "attachments": [
      {
        "filename": "receipt.pdf",
        "contentType": "application/pdf",
        "size": 12345,
        "url": "https://inbound.lettr.com/attachments/abc123"
      }
    ],
    "headers": {
      "message-id": "<abc123@example.com>",
      "date": "Mon, 15 Jan 2024 10:30:00 +0000",
      "in-reply-to": "<original@example.com>"
    },
    "receivedAt": "2024-01-15T10:30:15Z",
    "spamScore": 0.5,
    "domain": "mail.example.com"
  }
}
```

Lettr automatically handles MIME decoding, character encoding (converting to UTF-8), and multipart message extraction. For a complete breakdown of each field and how to work with them, see [Email Parsing](/learn/receiving/parsing).

## Key Capabilities

### Email Routing

Route incoming emails to different handlers based on recipient, content, or custom rules:

```javascript
app.post('/webhooks/inbound', async (req, res) => {
  const { to, from, subject, text } = req.body.data;
  const recipient = to[0].toLowerCase();

  if (recipient.startsWith('support@')) {
    await createSupportTicket({ from, subject, body: text });
  } else if (recipient.startsWith('sales@')) {
    await notifySalesTeam({ from, subject, body: text });
  } else if (recipient.match(/^reply\+/)) {
    const ticketId = recipient.match(/^reply\+([^@]+)@/)[1];
    await addReplyToTicket(ticketId, { from, body: text });
  }

  res.sendStatus(200);
});
```

The `reply+` pattern above is called variable addressing (or plus addressing). It's a common way to encode context in the recipient address so you can route replies back to the right record. See [Routing](/learn/receiving/routing) for more patterns including routing by subject, sender domain, and content.

### Spam Filtering

Every email includes a spam score, and you can configure automatic filtering:

```javascript
// Filter based on spam score
if (email.spamScore >= 6) {
  await quarantineAsSpam(email);
  return;
}

// Or configure domain-level filtering
await lettr.domains.update('mail.example.com', {
  spamFilter: 'aggressive' // 'off', 'moderate', 'aggressive'
});
```

Spam scores range from 0 to 10 — lower is better. Scores below 3 are generally safe, 3–6 are suspicious, and above 6 are likely spam. See [Spam Filtering](/learn/receiving/spam-filtering) for advanced detection patterns and allowlist/blocklist management.

### Attachment Handling

Attachments are automatically extracted and made available via secure URLs:

```javascript
for (const attachment of email.attachments) {
  const response = await fetch(attachment.url);
  const buffer = await response.arrayBuffer();
  await saveToStorage(attachment.filename, Buffer.from(buffer));
}
```

<Warning>
  Attachment URLs expire after 24 hours. Download and store attachments promptly if you need them longer.
</Warning>

Each attachment includes `filename`, `contentType`, `size` (in bytes), and a download `url`. Limits are 25 MB per file, 100 MB per email, and up to 50 attachments per email. See [Attachments](/learn/receiving/attachments) for storage examples (S3, GCS) and security best practices including file type verification and malware scanning.

### Reply Tracking

Track replies to your transactional emails by using variable reply-to addresses:

```javascript
// When sending an email
await lettr.emails.send({
  from: 'support@example.com',
  to: ['customer@example.com'],
  subject: 'Your support request',
  html: content,
  reply_to: `reply+ticket_${ticketId}@mail.example.com`
});

// When receiving the reply
const match = recipient.match(/^reply\+ticket_([^@]+)@/);
if (match) {
  const ticketId = match[1];
  await addReplyToTicket(ticketId, emailData);
}
```

For more advanced threading, use email headers like `Message-ID`, `In-Reply-To`, and `References` to build full conversation threads. See [Reply Tracking](/learn/receiving/reply-tracking) for header-based threading, auto-reply detection, and a complete support ticket example.

## Real-World Examples

### Support Ticket System

Create support tickets from incoming emails and track the conversation thread:

```javascript
app.post('/webhooks/inbound', async (req, res) => {
  const email = req.body.data;
  const recipient = email.to[0].toLowerCase();

  // Check if this is a reply to an existing ticket
  const replyMatch = recipient.match(/^reply\+ticket_([^@]+)@/);

  if (replyMatch) {
    // Add reply to existing ticket
    const ticketId = replyMatch[1];
    await db.ticketReplies.create({
      ticketId,
      from: email.from,
      body: email.text,
      receivedAt: email.receivedAt
    });
  } else {
    // Create new ticket
    const ticket = await db.tickets.create({
      from: email.from,
      fromName: email.fromName,
      subject: email.subject,
      body: email.text,
      status: 'open'
    });

    // Send acknowledgment with reply-to address for threading
    await lettr.emails.send({
      from: 'support@example.com',
      to: [email.from],
      subject: `Re: ${email.subject}`,
      html: '<p>We received your request and will respond shortly.</p>',
      reply_to: `reply+ticket_${ticket.id}@mail.example.com`
    });
  }

  res.sendStatus(200);
});
```

### Email-to-Task Automation

Parse incoming emails to create tasks in your project management system:

```javascript
app.post('/webhooks/inbound', async (req, res) => {
  const { from, subject, text, attachments } = req.body.data;

  // Create task from email
  const task = await projectManager.createTask({
    title: subject,
    description: text,
    reporter: from,
    attachments: attachments.map(a => ({
      name: a.filename,
      url: a.url  // Download within 24 hours
    }))
  });

  // Confirm task creation
  await lettr.emails.send({
    from: 'tasks@example.com',
    to: [from],
    subject: `Task created: ${subject}`,
    html: `<p>Task <strong>${task.id}</strong> has been created from your email.</p>`
  });

  res.sendStatus(200);
});
```

## Using Subdomains

We recommend using a subdomain for inbound email to keep it separate from your primary email:

| Subdomain | Use Case |
|-----------|----------|
| `mail.example.com` | General inbound processing |
| `reply.example.com` | Reply tracking for transactional emails |
| `support.example.com` | Customer support emails |
| `inbound.example.com` | Automated workflow triggers |

This lets you keep your root domain's MX records pointing to your regular email provider while routing specific subdomains through Lettr.

## Processing Best Practices

- **Respond quickly** — Return a `200` status from your webhook endpoint within a few seconds. If processing is complex, accept the webhook and process asynchronously via a queue.
- **Handle duplicates** — Webhooks may be delivered more than once. Use the event `id` to deduplicate.
- **Store before processing** — Save the raw webhook payload before doing any processing, so you can replay events if something fails.
- **Validate attachments** — Verify file types and scan for malware before processing attachments from unknown senders.

See [Best Practices](/learn/receiving/best-practices) for architecture patterns, reliability strategies, and monitoring recommendations.

## Learn More

<CardGroup cols={2}>
  <Card title="Setup Guide" icon="gear" href="/learn/receiving/setup">
    Step-by-step domain and webhook configuration
  </Card>
  <Card title="Webhooks" icon="webhook" href="/learn/webhooks/introduction">
    Webhook configuration and event handling
  </Card>
  <Card title="Routing" icon="route" href="/learn/receiving/routing">
    Route emails to different handlers
  </Card>
  <Card title="Attachments" icon="paperclip" href="/learn/receiving/attachments">
    Handle incoming file attachments
  </Card>
  <Card title="Spam Filtering" icon="shield" href="/learn/receiving/spam-filtering">
    Filter and manage spam
  </Card>
  <Card title="Reply Tracking" icon="reply" href="/learn/receiving/reply-tracking">
    Track and thread email replies
  </Card>
  <Card title="Email Parsing" icon="code" href="/learn/receiving/parsing">
    Understanding parsed email data
  </Card>
  <Card title="Security" icon="lock" href="/learn/receiving/security">
    Secure your inbound processing
  </Card>
  <Card title="Best Practices" icon="star" href="/learn/receiving/best-practices">
    Build reliable email processing
  </Card>
</CardGroup>

## Related Topics

<CardGroup cols={2}>
  <Card title="Inbound Domains" icon="globe" href="/learn/domains/inbound-domains">
    Domain configuration details
  </Card>
  <Card title="Webhooks Overview" icon="bell" href="/learn/webhooks/introduction">
    General webhook documentation
  </Card>
</CardGroup>
