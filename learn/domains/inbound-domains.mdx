---
title: Inbound Domains
description: "Configure domains to receive emails and process them via webhooks"
---

# Inbound Domains

Inbound domains allow you to receive emails at your domain and process them programmatically through Lettr. When someone sends an email to an address on your inbound domain, Lettr receives it and forwards the content to your application via webhooks.

## Use Cases

Inbound email processing enables powerful features:

- **Reply Handling** - Process replies to your outgoing emails
- **Support Tickets** - Automatically create tickets from incoming emails
- **Email Parsing** - Extract data from incoming emails (invoices, receipts, etc.)
- **Forward Processing** - Handle forwarded emails from users
- **Automation Triggers** - Start workflows based on incoming emails

## How Inbound Works

```
┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│   Sender     │ ──────▶ │    Lettr     │ ──────▶ │  Your App    │
│ Sends Email  │   MX    │  Receives    │ Webhook │  Processes   │
└──────────────┘         └──────────────┘         └──────────────┘
```

1. Add the three MX records (shown in the dashboard) so your domain’s mail is received by Lettr
2. Emails sent to any address `*@yourdomain.com` are received by Lettr
3. Lettr parses the email and sends a webhook to your application
4. Your application processes the email data

## Setup Inbound Domain

<Steps>
  <Step title="Add domain in Dashboard">
    Go to **Domains → Inbound Domains** and click **+ New Inbound Domain**. Enter your domain (e.g. `inbound.example.com`).
  </Step>
  <Step title="Add MX records">
    In the dashboard you’ll see the **MX Records** section: “Required for receiving inbound emails on this domain.” Copy the **HOSTNAME** and **MX RECORD 1**, **MX RECORD 2**, **MX RECORD 3** values and add them to your DNS. Use the provider guide button (e.g. **AWS Route53 guide**) if your DNS is on a supported provider.
  </Step>
  <Step title="Configure webhook">
    Set up a webhook endpoint to receive incoming emails (see [Webhooks](/learn/webhooks/introduction)).
  </Step>
  <Step title="Verify MX records">
    In the dashboard, click **Verify MX Records**. Status will move from **Pending** to verified once DNS has propagated.
  </Step>
</Steps>

## DNS Configuration

The dashboard shows the exact values for your domain. You need **three MX records** (all priority `10`) pointing to Lettr’s inbound servers:

| Record    | Type | Host (your domain/subdomain) | Value (mail server)     | Priority |
|-----------|------|------------------------------|-------------------------|----------|
| MX Record 1 | MX   | `@` or e.g. `inbound`        | `rx1.sparkpostmail.com` | 10       |
| MX Record 2 | MX   | `@` or e.g. `inbound`        | `rx2.sparkpostmail.com` | 10       |
| MX Record 3 | MX   | `@` or e.g. `inbound`        | `rx3.sparkpostmail.com` | 10       |

In the dashboard, the **MX Records** section lists **HOSTNAME** (your domain) and **MX RECORD 1**, **MX RECORD 2**, **MX RECORD 3** (each with a copy button). Add these in your DNS; status stays **Pending** until you click **Verify MX Records** and DNS has propagated.

<Tip>
  Use a subdomain like `inbound.example.com` so your main domain’s MX records stay unchanged for regular email.
</Tip>

## Via API

Create the inbound domain with `POST /domains`. The request body contains only the domain name; the dashboard then shows the MX records to add.

```javascript
const response = await fetch('https://app.lettr.com/api/domains', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer YOUR_API_KEY'
  },
  body: JSON.stringify({ domain: 'inbound.example.com' })
});

const { message, data } = await response.json();
// Then add the three MX records (rx1/rx2/rx3.sparkpostmail.com, priority 10) in your DNS—values are shown in the dashboard for this domain.
```

Configure a webhook for incoming email events via the dashboard or the [Webhooks API](/api-reference/webhooks/list-webhooks). See [Create Domain](/api-reference/domains/create-domain) for the full request/response schema.

## Webhook Payload

Inbound webhooks send a payload wrapped in `msys.relay_event`. Use the `type` field to distinguish events.

### relay_injection

Sent when an inbound message is received (injected):

```json
{
  "msys": {
    "relay_event": {
      "event_id": "92356927693813856",
      "rcpt_to": "recipient@example.com",
      "rcpt_hash": "2aae6c35c94fcfb415dbe95f408b9ce91ee846ed",
      "raw_rcpt_to": "recipient@example.com",
      "msg_size": "1337",
      "routing_domain": "example.com",
      "customer_id": "1",
      "sending_ip": "18.236.253.72",
      "type": "relay_injection",
      "subaccount_id": "101",
      "timestamp": "1460989507",
      "ip_pool": "example-ip-pool",
      "origination": "inbound",
      "message_id": "000443ee14578172be22",
      "msg_from": "sender@example.com",
      "recv_method": "esmtp",
      "injection_time": "2016-04-18T14:25:07.000Z",
      "relay_id": "123-456-789"
    }
  }
}
```

### relay_delivery

Sent when the inbound message has been delivered:

```json
{
  "msys": {
    "relay_event": {
      "event_id": "92356927693813856",
      "routing_domain": "example.com",
      "rcpt_to": "recipient@example.com",
      "rcpt_hash": "2aae6c35c94fcfb415dbe95f408b9ce91ee846ed",
      "raw_rcpt_to": "recipient@example.com",
      "type": "relay_delivery",
      "message_id": "000443ee14578172be22",
      "msg_from": "sender@example.com",
      "recv_method": "esmtp",
      "subaccount_id": "101",
      "ip_pool": "example-ip-pool",
      "queue_time": "12",
      "customer_id": "1",
      "timestamp": "1460989507",
      "num_retries": "2",
      "origination": "inbound",
      "delv_method": "esmtp",
      "sending_ip": "18.236.253.72",
      "injection_time": "2016-04-18T14:25:07.000Z",
      "relay_id": "123-456-789"
    }
  }
}
```

### Common fields

| Field | Description |
|-------|-------------|
| `type` | `relay_injection` (message received) or `relay_delivery` (message delivered) |
| `origination` | `inbound` for inbound relay events |
| `msg_from` | Sender address |
| `rcpt_to` / `raw_rcpt_to` | Recipient address |
| `routing_domain` | Domain that received the message |
| `message_id` | Message identifier |
| `event_id` | Event identifier |
| `timestamp` | Unix timestamp |
| `injection_time` | ISO 8601 injection time |
| `relay_id` | Relay identifier |

## Handling Incoming Emails

Example webhook handler using the relay payload:

```javascript
app.post('/webhooks/inbound-email', async (req, res) => {
  const event = req.body?.msys?.relay_event;
  if (!event || event.origination !== 'inbound') {
    return res.status(200).send('OK');
  }

  if (event.type === 'relay_injection') {
    // New inbound message received
    const { msg_from, rcpt_to, message_id, routing_domain } = event;
    await createTicket({
      from: msg_from,
      to: rcpt_to,
      messageId: message_id,
      domain: routing_domain
    });
  } else if (event.type === 'relay_delivery') {
    // Inbound message delivered
    const { message_id } = event;
    await markInboundDelivered(message_id);
  }

  res.status(200).send('OK');
});
```

## Catch-All Addresses

With an inbound domain, all addresses are automatically catch-all:

- `support@inbound.example.com` ✓
- `sales@inbound.example.com` ✓
- `anything@inbound.example.com` ✓

You can route emails based on `rcpt_to` (or `raw_rcpt_to`) in the webhook payload.

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Not receiving emails | Add all three MX records (rx1, rx2, rx3 .sparkpostmail.com, priority 10) and click **Verify MX Records** in the dashboard |
| Webhook not called | Check webhook URL is accessible and returns 2xx; ensure payload is read from `body.msys.relay_event` |

## Next Steps

<CardGroup cols={2}>
  <Card title="Webhooks" icon="webhook" href="/learn/webhooks/introduction">
    Learn more about webhook configuration
  </Card>
  <Card title="Storage Domains" icon="image" href="/learn/domains/storage-domains">
    Set up image hosting for your emails
  </Card>
</CardGroup>
