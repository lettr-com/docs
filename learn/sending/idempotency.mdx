---
title: Idempotency
description: "Prevent duplicate emails with request tracking"
---

# Idempotency

Prevent duplicate emails and safely retry failed requests using request IDs and idempotency patterns.

## Request IDs

Every email send returns a unique `request_id`:

```javascript
const response = await lettr.emails.send({
  from: 'you@example.com',
  to: ['recipient@example.com'],
  subject: 'Order Confirmation',
  html: '<p>Your order is confirmed!</p>'
});

console.log(response.data.request_id);
// "7582751837467401763"
```

## Using Request IDs

Store the request ID to:

- Track email delivery status
- Query sent emails
- Debug delivery issues
- Correlate with webhook events

```javascript
// Store with your order
await db.orders.update(orderId, {
  confirmation_email_request_id: response.data.request_id
});

// Later, check delivery status
const email = await lettr.emails.get(requestId);
console.log(email.status);
```

## Preventing Duplicate Sends

Implement idempotency in your application:

```javascript
async function sendOrderConfirmation(order) {
  // Check if already sent
  if (order.confirmation_email_sent) {
    console.log('Email already sent for order', order.id);
    return;
  }

  const response = await lettr.emails.send({
    from: 'orders@example.com',
    to: [order.customer_email],
    subject: `Order #${order.id} Confirmed`,
    template_slug: 'order-confirmation',
    substitution_data: { order },
    metadata: {
      order_id: order.id,
      idempotency_key: `order-confirmation-${order.id}`
    }
  });

  // Mark as sent
  await db.orders.update(order.id, {
    confirmation_email_sent: true,
    confirmation_email_request_id: response.data.request_id
  });
}
```

## Idempotency with Metadata

Use metadata to track and deduplicate:

```javascript
// Before sending, check if already sent
const existingEmails = await lettr.emails.list({
  metadata: {
    idempotency_key: `password-reset-${userId}-${resetToken}`
  }
});

if (existingEmails.data.length > 0) {
  console.log('Password reset email already sent');
  return existingEmails.data[0];
}

// Send the email
const response = await lettr.emails.send({
  from: 'security@example.com',
  to: [userEmail],
  subject: 'Password Reset Request',
  template_slug: 'password-reset',
  metadata: {
    idempotency_key: `password-reset-${userId}-${resetToken}`,
    user_id: userId
  }
});
```

## Safe Retry Pattern

Handle network failures with safe retries:

```javascript
async function sendEmailWithRetry(emailData, maxRetries = 3) {
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await lettr.emails.send(emailData);
      return response;
    } catch (error) {
      lastError = error;

      // Don't retry client errors (4xx)
      if (error.status >= 400 && error.status < 500) {
        throw error;
      }

      // Wait before retrying (exponential backoff)
      if (attempt < maxRetries) {
        await sleep(Math.pow(2, attempt) * 1000);
      }
    }
  }

  throw lastError;
}
```

## Request ID in Webhooks

Webhook events include the request ID for correlation:

```json
{
  "type": "email.delivered",
  "data": {
    "request_id": "7582751837467401763",
    "message_id": "msg_abc123",
    "to": "recipient@example.com",
    "metadata": {
      "order_id": "order_12345"
    }
  }
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Always Store Request IDs">
    Store the request_id with your business records to track email delivery.
  </Accordion>
  <Accordion title="Use Meaningful Idempotency Keys">
    Create keys that uniquely identify the email purpose, like `order-confirmation-{order_id}`.
  </Accordion>
  <Accordion title="Check Before Sending">
    For critical emails, check if already sent before making the API call.
  </Accordion>
  <Accordion title="Handle Timeouts Carefully">
    A timeout doesn't mean the email wasn't sent. Check status before retrying.
  </Accordion>
</AccordionGroup>

## Timeout Handling

When a request times out, the email may have been sent:

```javascript
async function safeSend(emailData) {
  try {
    return await lettr.emails.send(emailData);
  } catch (error) {
    if (error.code === 'ETIMEDOUT' || error.code === 'ECONNRESET') {
      // Check if email was sent using metadata
      const sent = await lettr.emails.list({
        metadata: { idempotency_key: emailData.metadata.idempotency_key }
      });

      if (sent.data.length > 0) {
        return { data: sent.data[0], alreadySent: true };
      }
    }
    throw error;
  }
}
```
