---
title: Errors & Retries
description: "Handle errors and implement retry logic"
---

# Errors & Retries

Learn how to handle errors and implement robust retry logic for reliable email delivery.

## Error Response Format

All API errors follow a consistent format:

```json
{
  "status": "error",
  "error_code": "validation_error",
  "message": "The given data was invalid.",
  "errors": {
    "to": ["The to field is required."],
    "subject": ["The subject must not exceed 998 characters."]
  }
}
```

## Common Error Codes

| Error Code | HTTP Status | Description |
|------------|-------------|-------------|
| `validation_error` | 422 | Invalid request parameters |
| `invalid_sending_domain` | 422 | Sender domain not verified |
| `unconfigured_sending_domain` | 422 | Domain not ready for sending |
| `template_not_found` | 404 | Template slug not found |
| `rate_limit_exceeded` | 429 | Too many requests |
| `unauthorized` | 401 | Invalid or missing API key |
| `forbidden` | 403 | API key lacks permission |
| `transmission_failed` | 500 | Email delivery failed |

## Validation Errors

Handle validation errors by checking the `errors` object:

```javascript
try {
  await lettr.emails.send(emailData);
} catch (error) {
  if (error.status === 422) {
    console.log('Validation errors:', error.errors);

    // Handle specific field errors
    if (error.errors.to) {
      console.log('Invalid recipients:', error.errors.to);
    }
    if (error.errors.from) {
      console.log('Invalid sender:', error.errors.from);
    }
  }
}
```

## Domain Errors

Handle domain configuration errors:

```javascript
try {
  await lettr.emails.send({
    from: 'you@unverified-domain.com',
    to: ['recipient@example.com'],
    subject: 'Hello',
    html: '<p>Hello!</p>'
  });
} catch (error) {
  if (error.error_code === 'invalid_sending_domain') {
    console.log('Domain not verified. Please verify your domain first.');
  }
  if (error.error_code === 'unconfigured_sending_domain') {
    console.log('Domain DNS records not configured correctly.');
  }
}
```

## Retry Logic

Implement intelligent retry logic:

```javascript
async function sendEmailWithRetry(emailData, options = {}) {
  const {
    maxRetries = 3,
    baseDelay = 1000,
    maxDelay = 30000
  } = options;

  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await lettr.emails.send(emailData);
    } catch (error) {
      lastError = error;

      // Don't retry client errors (except rate limits)
      if (error.status >= 400 && error.status < 500 && error.status !== 429) {
        throw error;
      }

      // Calculate delay with exponential backoff
      const delay = Math.min(
        baseDelay * Math.pow(2, attempt - 1),
        maxDelay
      );

      // Use retry-after header if provided
      const retryAfter = error.retryAfter
        ? error.retryAfter * 1000
        : delay;

      console.log(`Attempt ${attempt} failed. Retrying in ${retryAfter}ms...`);
      await sleep(retryAfter);
    }
  }

  throw lastError;
}
```

## Retryable vs Non-Retryable Errors

| Error Type | Retryable | Action |
|------------|-----------|--------|
| `429` Rate limit | Yes | Wait and retry with backoff |
| `500` Server error | Yes | Retry with backoff |
| `502/503/504` Gateway errors | Yes | Retry with backoff |
| `401` Unauthorized | No | Check API key |
| `403` Forbidden | No | Check API key permissions |
| `422` Validation | No | Fix request data |
| `404` Not found | No | Check template/resource exists |

## Error Handling Best Practices

```javascript
async function sendEmail(emailData) {
  try {
    const response = await sendEmailWithRetry(emailData);
    return { success: true, data: response.data };
  } catch (error) {
    // Log error for debugging
    console.error('Email send failed:', {
      error_code: error.error_code,
      message: error.message,
      to: emailData.to,
      timestamp: new Date().toISOString()
    });

    // Handle specific errors
    switch (error.error_code) {
      case 'validation_error':
        return { success: false, error: 'Invalid email data', details: error.errors };

      case 'invalid_sending_domain':
        return { success: false, error: 'Sender domain not verified' };

      case 'rate_limit_exceeded':
        return { success: false, error: 'Rate limit exceeded', retryAfter: error.retryAfter };

      default:
        return { success: false, error: 'Failed to send email' };
    }
  }
}
```

## Soft Bounce Retries

Lettr automatically retries soft bounces:

| Bounce Type | Auto-Retry | Max Attempts |
|-------------|------------|--------------|
| Soft bounce (mailbox full) | Yes | 3 |
| Soft bounce (server error) | Yes | 3 |
| Hard bounce (invalid address) | No | - |

## Circuit Breaker Pattern

For high-volume sending, implement a circuit breaker:

```javascript
class EmailCircuitBreaker {
  constructor(threshold = 5, resetTimeout = 60000) {
    this.failures = 0;
    this.threshold = threshold;
    this.resetTimeout = resetTimeout;
    this.state = 'closed';
    this.lastFailure = null;
  }

  async send(emailData) {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailure > this.resetTimeout) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open');
      }
    }

    try {
      const result = await lettr.emails.send(emailData);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failures = 0;
    this.state = 'closed';
  }

  onFailure() {
    this.failures++;
    this.lastFailure = Date.now();
    if (this.failures >= this.threshold) {
      this.state = 'open';
    }
  }
}
```

## Monitoring Errors

Set up error monitoring with webhooks:

```javascript
// Webhook handler for delivery failures
app.post('/webhooks/lettr', (req, res) => {
  const event = req.body;

  if (event.type === 'email.failed' || event.type === 'email.bounced') {
    // Alert your team
    alertTeam({
      type: event.type,
      email_id: event.data.email_id,
      recipient: event.data.to,
      error: event.data.error_message
    });
  }

  res.sendStatus(200);
});
```
